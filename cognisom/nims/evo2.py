"""
Evo2 NIM Client
===============

Genomic foundation model (40B parameters) for DNA sequence generation
and analysis. Interprets and generates DNA sequences across biological
scales — from individual genes to entire genomes.
"""

import logging
from dataclasses import dataclass, field
from typing import Dict, List, Optional

from .client import NIMClient

logger = logging.getLogger(__name__)

ENDPOINT_GENERATE = "arc/evo2/generate"
ENDPOINT_FORWARD = "arc/evo2/forward"


@dataclass
class GeneratedDNA:
    """DNA sequence generated by Evo2."""
    input_sequence: str
    generated_sequence: str
    num_tokens_generated: int
    sampled_probs: Optional[List[float]] = None


@dataclass
class Evo2ForwardResult:
    """Forward pass result with logits and probabilities."""
    sequence: str
    logits: Optional[List] = None       # Per-token logits (512-token vocab)
    sampled_probs: Optional[List[float]] = None   # Per-token confidence
    elapsed_ms: Optional[float] = None


class Evo2Client(NIMClient):
    """Client for Evo2-40B genomic foundation model NIM.

    Evo2 is a biological foundation model that can interpret and generate
    DNA sequences. Use it for:
    - Generating DNA sequence continuations
    - Scoring mutations at the genomic level
    - Analyzing promoter/regulatory regions
    - Predicting mutation effects on gene function

    Example:
        client = Evo2Client()

        # Generate DNA continuation
        dna = client.generate("ATGCGATCGATCG", num_tokens=50)
        print(f"Generated: {dna.generated_sequence[:50]}...")

        # Score a point mutation
        impact = client.score_mutation(
            wild_type="ATGCGATCGATCG",
            mutant="ATGCGATCAATCG",  # G→A at position 9
            position=8,
        )
        print(f"Log-likelihood ratio: {impact['log_likelihood_ratio']:.3f}")
    """

    def generate(self, sequence: str, num_tokens: int = 100,
                 temperature: float = 0.7, top_k: int = 3,
                 random_seed: Optional[int] = None) -> GeneratedDNA:
        """Generate DNA sequence continuation.

        Args:
            sequence: Input DNA sequence (A/T/G/C).
            num_tokens: Number of nucleotides to generate.
            temperature: Sampling temperature (higher = more random).
            top_k: Top-k sampling parameter.
            random_seed: Optional seed for reproducibility.

        Returns:
            GeneratedDNA with input and generated sequences.
        """
        payload = {
            "sequence": sequence,
            "num_tokens": num_tokens,
            "temperature": temperature,
            "top_k": top_k,
        }
        if random_seed is not None:
            payload["random_seed"] = random_seed

        result = self._post(ENDPOINT_GENERATE, payload, timeout=300)

        generated_seq = result.get("sequence", "")
        probs = result.get("sampled_probs", None)

        dna = GeneratedDNA(
            input_sequence=sequence,
            generated_sequence=generated_seq,
            num_tokens_generated=len(generated_seq) - len(sequence),
            sampled_probs=probs,
        )
        logger.info(f"Evo2 generated {dna.num_tokens_generated} tokens "
                     f"from {len(sequence)}-nt input")
        return dna

    def forward(self, sequence: str,
                enable_logits: bool = True,
                enable_probs: bool = True) -> Evo2ForwardResult:
        """Run forward pass to get per-token logits and probabilities.

        Args:
            sequence: DNA sequence to analyze.
            enable_logits: Return logits for each position.
            enable_probs: Return sampled probabilities.

        Returns:
            Evo2ForwardResult with logits and probabilities.
        """
        payload = {
            "sequence": sequence,
            "enable_logits": enable_logits,
            "enable_sampled_probs": enable_probs,
        }

        result = self._post(ENDPOINT_FORWARD, payload, timeout=300)

        return Evo2ForwardResult(
            sequence=sequence,
            logits=result.get("logits", None),
            sampled_probs=result.get("sampled_probs", None),
            elapsed_ms=result.get("elapsed_ms_per_token", None),
        )

    def score_mutation(self, wild_type: str, mutant: str,
                       position: int) -> Dict[str, float]:
        """Score a point mutation by comparing log-likelihoods.

        Computes the log-likelihood ratio between wild-type and mutant
        sequences at the mutation position using Evo2's forward pass.

        Args:
            wild_type: Wild-type DNA sequence.
            mutant: Mutant DNA sequence.
            position: 0-indexed position of the mutation.

        Returns:
            Dict with log_likelihood_ratio, wt_prob, mut_prob,
            and impact_score (0-1, higher = more disruptive).
        """
        wt_result = self.forward(wild_type)
        mut_result = self.forward(mutant)

        wt_prob = 1.0
        mut_prob = 1.0
        if wt_result.sampled_probs and position < len(wt_result.sampled_probs):
            wt_prob = wt_result.sampled_probs[position]
        if mut_result.sampled_probs and position < len(mut_result.sampled_probs):
            mut_prob = mut_result.sampled_probs[position]

        import math
        llr = math.log(mut_prob + 1e-10) - math.log(wt_prob + 1e-10)

        # Impact: negative LLR means mutation is less likely (more disruptive)
        impact = max(0.0, min(1.0, -llr / 5.0))

        return {
            "log_likelihood_ratio": llr,
            "wt_probability": wt_prob,
            "mut_probability": mut_prob,
            "impact_score": impact,
            "position": position,
            "wt_base": wild_type[position] if position < len(wild_type) else "?",
            "mut_base": mutant[position] if position < len(mutant) else "?",
        }
